	//compute the intersection points for the last curve network&other orthogonal plane
	//and curve network on other planes&the last plane, deform the curves
	//static bool FitLastCN(Plane_3 RefPlane[3],vector<CurveNetwork>& vecCurveNetwork, 
	//	vector<Point_3>& vecCurvePlaneIntersectPoint,vector<int>& vecCurvePlaneIntersectType);

//bool CCrossSectionProc::FitLastCN(Plane_3 RefPlane[3],vector<CurveNetwork>& vecCurveNetwork, 
//								  vector<Point_3>& vecCurvePlaneIntersectPoint,vector<int>& vecCurvePlaneIntersectType)
//{
//	bool bResult=true;
//
//	for (unsigned int iPlane=0;iPlane<vecCurveNetwork.size()-1;iPlane++)
//	{
//		if (vecCurveNetwork.at(iPlane).ProfilePlaneType==vecCurveNetwork.back().ProfilePlaneType)//parallel,don't check
//		{
//			continue;
//		}
//		vector<int>::iterator::difference_type CurrentNum;//how many intersection points between current CN and plane of last CN
//		CurrentNum = count(vecCurveNetwork.at(iPlane).IntersectCNInd.begin(), 
//			vecCurveNetwork.at(iPlane).IntersectCNInd.end(), vecCurveNetwork.size()-1);
//		vector<int>::iterator::difference_type BackNum;//how many intersection points between last CN and plane of current CN
//		BackNum = count(vecCurveNetwork.back().IntersectCNInd.begin(), 
//			vecCurveNetwork.back().IntersectCNInd.end(), iPlane);
//		if (CurrentNum!=BackNum)//intersect number don't equal
//		{
//			AfxMessageBox("Intersect Num don't equal");
//			DBWindowWrite("rule 4 is violated...\n");
//			//DeleteLastCS(RefPlane,vecCurveNetwork,vecCurvePlaneIntersectPoint,vecCurvePlaneIntersectType);			
//			bResult=false;
//			break;
//		}
//		else if (CurrentNum==0)//both have no intersect
//		{
//			continue;
//		}
//		//intersect number equal
//		//index of first intersection point between current CN and plane of last CN
//		vector<int>::iterator pFindCurrent=find(vecCurveNetwork.at(iPlane).IntersectCNInd.begin(),vecCurveNetwork.at(iPlane).IntersectCNInd.end(),
//			vecCurveNetwork.size()-1);
//		int iFindCurrent=pFindCurrent-vecCurveNetwork.at(iPlane).IntersectCNInd.begin();
//		//index of first intersection point between last CN and plane of current CN
//		vector<int>::iterator pFindBack=find(vecCurveNetwork.back().IntersectCNInd.begin(),vecCurveNetwork.back().IntersectCNInd.end(),
//			iPlane);
//		int iFindBack=pFindBack-vecCurveNetwork.back().IntersectCNInd.begin();
//
//		vector<Point_3> CurrentInterPoint,BackInterPoint;
//		//all the intersection points between current CN and plane of last CN
//		CurrentInterPoint.insert(CurrentInterPoint.end(),vecCurveNetwork.at(iPlane).CurvePlaneIntersect.begin()+iFindCurrent,
//			vecCurveNetwork.at(iPlane).CurvePlaneIntersect.begin()+iFindCurrent+CurrentNum);
//		//all the intersection points between last CN and plane of current CN
//		BackInterPoint.insert(BackInterPoint.end(),vecCurveNetwork.back().CurvePlaneIntersect.begin()+iFindBack,
//			vecCurveNetwork.back().CurvePlaneIntersect.begin()+iFindBack+BackNum);
//		vector<vector<int>> GroupResult;
//		GeometryAlgorithm::GroupNearestPoints(CurrentInterPoint,BackInterPoint,GroupResult);//,vecMidPoint
//		//compute the destination point between each pair of nearest points
//		//here to avoid the re-movement of the point on existing curve,which will cause the originally intersected
//		//curves become disconnected
//		//set the destination point to the one on the existing curve directly, other than the one
//		//on the last curve(i.e. only deform the last curve)
//		vector<Point_3> vecMidPoint;
//		for (unsigned int i=0;i<GroupResult.size();i++)
//		{
//			vecMidPoint.push_back(CurrentInterPoint.at(GroupResult.at(i).front()));
//		}
//
//		//indices of curves and points of the current curve network
//		//which are to be moved to a new positions
//		//move them to the new positions again after deformation
//		//to avoid their unwanted movement when they belong to the ROI of other
//		//constraint points
//		vector<int> viCurrentConstrPointCurveIndex;
//		vector<int> viCurrentConstrPointIndex;
//		//same guys for the last curve network
//		vector<int> viBackConstrPointCurveIndex;
//		vector<int> viBackConstrPointIndex;
//
//		const int iCurveDeformROIRange=6;
//		for (unsigned int iJoint=0;iJoint<vecMidPoint.size();iJoint++)
//		{
//			//for current curve network
//			//which curve
//			int iCurveIndex=vecCurveNetwork.at(iPlane).IntersectCurveIndex.at(iFindCurrent+GroupResult.at(iJoint).front());
//			//index of handle point
//			int iHandleIndex;
//			if (CGAL::has_larger_distance_to_point(CurrentInterPoint.at(iJoint),
//				vecCurveNetwork.at(iPlane).Profile3D.at(iCurveIndex).at(vecCurveNetwork.at(iPlane).NeighborInd.at(iFindCurrent+GroupResult.at(iJoint).front()).front()),
//				vecCurveNetwork.at(iPlane).Profile3D.at(iCurveIndex).at(vecCurveNetwork.at(iPlane).NeighborInd.at(iFindCurrent+GroupResult.at(iJoint).front()).back())))
//			{
//				iHandleIndex=vecCurveNetwork.at(iPlane).NeighborInd.at(iFindCurrent+GroupResult.at(iJoint).front()).back();
//			} 
//			else
//			{
//				iHandleIndex=vecCurveNetwork.at(iPlane).NeighborInd.at(iFindCurrent+GroupResult.at(iJoint).front()).front();
//			}
//			//store the indices
//			viCurrentConstrPointCurveIndex.push_back(iCurveIndex);
//			viCurrentConstrPointIndex.push_back(iHandleIndex);
//
//			//plane type
//			int iCurrentPlaneType=vecCurveNetwork.at(iPlane).ProfilePlaneType;
//			vector<int> iTemp0;iTemp0.push_back(iHandleIndex);
//			vector<Point_3> pTemp0;pTemp0.push_back(vecMidPoint.at(iJoint));
//			CCurveDeform::OpenCurveNaiveLaplacianDeform(vecCurveNetwork.at(iPlane).Profile3D.at(iCurveIndex),iTemp0,
//				pTemp0,iCurveDeformROIRange,iCurrentPlaneType);//
//
//			//for back curve network
//			//which curve
//			iCurveIndex=vecCurveNetwork.back().IntersectCurveIndex.at(iFindBack+GroupResult.at(iJoint).back());
//			//index of handle point
//			if (CGAL::has_larger_distance_to_point(BackInterPoint.at(iJoint),
//				vecCurveNetwork.back().Profile3D.at(iCurveIndex).at(vecCurveNetwork.back().NeighborInd.at(iFindBack+GroupResult.at(iJoint).back()).front()),
//				vecCurveNetwork.back().Profile3D.at(iCurveIndex).at(vecCurveNetwork.back().NeighborInd.at(iFindBack+GroupResult.at(iJoint).back()).back())))
//			{
//				iHandleIndex=vecCurveNetwork.back().NeighborInd.at(iFindBack+GroupResult.at(iJoint).back()).back();
//			} 
//			else
//			{
//				iHandleIndex=vecCurveNetwork.back().NeighborInd.at(iFindBack+GroupResult.at(iJoint).back()).front();
//			}
//			//store the indices
//			viBackConstrPointCurveIndex.push_back(iCurveIndex);
//			viBackConstrPointIndex.push_back(iHandleIndex);
//			//plane type
//			iCurrentPlaneType=vecCurveNetwork.back().ProfilePlaneType;
//			vector<int> iTemp1;iTemp1.push_back(iHandleIndex);
//			vector<Point_3> pTemp1;pTemp1.push_back(vecMidPoint.at(iJoint));
//			CCurveDeform::OpenCurveNaiveLaplacianDeform(vecCurveNetwork.back().Profile3D.at(iCurveIndex),iTemp1,
//				pTemp1,iCurveDeformROIRange,iCurrentPlaneType);
//		}
//		//force the constraint points to the new positions again after deformation
//		//to avoid their unwanted movement when they belong to the ROI of other
//		//constraint points
//		assert(viCurrentConstrPointCurveIndex.size()==vecMidPoint.size());
//		assert(viCurrentConstrPointIndex.size()==vecMidPoint.size());
//		assert(viBackConstrPointCurveIndex.size()==vecMidPoint.size());
//		assert(viBackConstrPointIndex.size()==vecMidPoint.size());
//		for (unsigned int iJoint=0;iJoint<vecMidPoint.size();iJoint++)
//		{
//			vecCurveNetwork.at(iPlane).Profile3D.at(viCurrentConstrPointCurveIndex.at(iJoint)).at(viCurrentConstrPointIndex.at(iJoint))
//				=vecMidPoint.at(iJoint);
//			vecCurveNetwork.back().Profile3D.at(viBackConstrPointCurveIndex.at(iJoint)).at(viBackConstrPointIndex.at(iJoint))
//				=vecMidPoint.at(iJoint);
//		}
//		//don't forget to update the 2d polygon
//		vecCurveNetwork.at(iPlane).Profile2D.clear();
//		for (unsigned int iPoly2D=0;iPoly2D<vecCurveNetwork.at(iPlane).Profile3D.size();iPoly2D++)
//		{
//			Polygon_2 NewProfile2D;
//			GeometryAlgorithm::PlanarPolygonToXOY(vecCurveNetwork.at(iPlane).Profile3D.at(iPoly2D),
//				NewProfile2D,vecCurveNetwork.at(iPlane).ProfilePlaneType);
//			vecCurveNetwork.at(iPlane).Profile2D.push_back(NewProfile2D);
//		}
//		GetCNIntersectPoints(vecCurveNetwork);
//	}
//	//don't forget to update the 2d polygon
//	vecCurveNetwork.back().Profile2D.clear();
//	for (unsigned int iPoly2D=0;iPoly2D<vecCurveNetwork.back().Profile3D.size();iPoly2D++)
//	{
//		Polygon_2 NewProfile2D;
//		GeometryAlgorithm::PlanarPolygonToXOY(vecCurveNetwork.back().Profile3D.at(iPoly2D),
//			NewProfile2D,vecCurveNetwork.back().ProfilePlaneType);
//		vecCurveNetwork.back().Profile2D.push_back(NewProfile2D);
//	}
//	GetCurvePlaneIntersectPoints(vecCurveNetwork,RefPlane,vecCurvePlaneIntersectPoint,vecCurvePlaneIntersectType);
//
//	return bResult;
//}

		//bResult=CCrossSectionProc::FitLastCN(this->RefPlane,this->vecCurveNetwork,
		//	this->vecCurvePlaneIntersectPoint,this->vecCurvePlaneIntersectType);


	//function related to multi-thread in mesh generation
	static DWORD WINAPI GetSubMeshThread(LPVOID pParaIn);

	
	//functions and variables related to multi-thread surface reconstruction
	//reconstruction results of all subspaces
	vector<vector<Point_3>> vecvecSubPoint;
	vector<vector<vector<int>>> vecvecSubSurf;
	int iTotalThreadCount;
	//event used for sychronizing threads
	HANDLE* phEventThread;
	//event used for sychronizing iTotalThreadCount
	HANDLE hEventThrCnt;
	//event used for sychronizing result (vecvecSubPoint & vecvecSubSurf)
	HANDLE hEventThrResult;


	//multi-thread
	this->vecvecSubPoint.clear();
	this->vecvecSubSurf.clear();
	this->iTotalThreadCount=0;
	//create event
	this->phEventThread=new HANDLE[this->iSSspacenum];
	for (int i=0;i<this->iSSspacenum;i++)
	{
		this->phEventThread[i]=CreateEvent( 
			NULL,         // default security attributes
			true,         // manual-reset event
			false,        // initial state is non-signaled
			NULL);
	}
	this->hEventThrCnt=CreateEvent(NULL,true,true,NULL);
	this->hEventThrResult=CreateEvent(NULL,true,true,NULL);
	/*create thread*/
	for (int i=0;i<this->iSSspacenum;i++)
	{
		DWORD threadId;
		HANDLE hThrd=CreateThread(NULL,0,GetSubMeshThread,(LPVOID)this,0,&threadId);
	}

	WaitForMultipleObjects(this->iSSspacenum,this->phEventThread,TRUE,INFINITE);

	delete [] phEventThread;



DWORD WINAPI KW_CS2Surf::GetSubMeshThread(LPVOID pParaIn)
{
	KW_CS2Surf* kwcs2surf=(KW_CS2Surf*) pParaIn;
	//get the id the the current subspace
	WaitForSingleObject(kwcs2surf->hEventThrCnt,INFINITE);
	ResetEvent(kwcs2surf->hEventThrCnt);
	int iSubSpaceId=kwcs2surf->iTotalThreadCount;
	kwcs2surf->iTotalThreadCount++;
	SetEvent(kwcs2surf->hEventThrCnt);
	//generate mesh
	DBWindowWrite("subspace %d reconstruction begins\n",iSubSpaceId);
	vector<Point_3> vecSubPoint;
	vector<vector<int>> vecSubSurf;
	bool bResult=kwcs2surf->GenSubMesh(iSubSpaceId,vecSubPoint,vecSubSurf);
	if (bResult)
	{
		//save the result,to maintain the correspondence of vecSubPoint&vecSubSurf
		//only one thread is allowed to save each time
		WaitForSingleObject(kwcs2surf->hEventThrResult,INFINITE);
		ResetEvent(kwcs2surf->hEventThrResult);
		kwcs2surf->vecvecSubPoint.push_back(vecSubPoint);
		kwcs2surf->vecvecSubSurf.push_back(vecSubSurf);
		SetEvent(kwcs2surf->hEventThrResult);
	}
	SetEvent(kwcs2surf->phEventThread[iSubSpaceId]);
	DBWindowWrite("subspace %d reconstruction ends\n",iSubSpaceId);
	return 0;
}



















	//collect the points on the face edges and record their new positions
	vector<int> vecPointToMove;
	vector<Point_3> vecPointNewPos;
	for (unsigned int i=0;i<Pwh3D.AssistOuterEdge.size();i++)
	{
		//get the current assist edge points
		int iStartPointID=Pwh3D.AssistOuterEdge.at(i);
		int iEndPointID=(Pwh3D.AssistOuterEdge.at(i)+1)%Pwh3D.outer_boundary.size();
		Point_3 StartPoint=Pwh3D.outer_boundary.at(iStartPointID);
		Point_3 EndPoint=Pwh3D.outer_boundary.at(iEndPointID);
		//judge which face edge does this assist outer edge lies on
		bool btestFound=false;
		for (unsigned int j=0;j<4;j++)
		{
			double dStartDist=CGAL::squared_distance(StartPoint,vecFaceEdge.at(j));
			double dEndDist=CGAL::squared_distance(EndPoint,vecFaceEdge.at(j));
			if (dStartDist<1 && dEndDist<1)
			{
				//check if this point has been moved
				vector<int>::iterator pFindStart=find(vecPointToMove.begin(),vecPointToMove.end(),iStartPointID);
				if (pFindStart==vecPointToMove.end())//not yet
				{
					vecPointToMove.push_back(iStartPointID);
					StartPoint=StartPoint+vecWidthVect.at(j)*EXTRU_OUTBOUND_PERTRU_DIST;
					vecPointNewPos.push_back(StartPoint);
				}
				else//has been moved,continue moving
				{
					int iPos=distance(vecPointToMove.begin(),pFindStart);
					vecPointNewPos.at(iPos)=vecPointNewPos.at(iPos)+vecWidthVect.at(j)*EXTRU_OUTBOUND_PERTRU_DIST;
				}
				vector<int>::iterator pFindEnd=find(vecPointToMove.begin(),vecPointToMove.end(),iEndPointID);
				if (pFindEnd==vecPointToMove.end())//not yet
				{
					vecPointToMove.push_back(iEndPointID);
					EndPoint=EndPoint+vecWidthVect.at(j)*EXTRU_OUTBOUND_PERTRU_DIST;
					vecPointNewPos.push_back(EndPoint);
				}
				else//has been moved,continue moving
				{
					int iPos=distance(vecPointToMove.begin(),pFindEnd);
					vecPointNewPos.at(iPos)=vecPointNewPos.at(iPos)+vecWidthVect.at(j)*EXTRU_OUTBOUND_PERTRU_DIST;
				}
				btestFound=true;
				break;
			}
		}
		assert(btestFound==true);
	}
	assert(vecPointToMove.size()==vecPointNewPos.size());
	//deform the outer boundary
	if (!vecPointToMove.empty())
	{
		//plane type:
		int iPlaneType=this->vecTempCN.at(FaceInfo.iFacePlaneID).ProfilePlaneType;
		CCurveDeform::ClosedCurveNaiveLaplacianDeform(Pwh3D.outer_boundary,vecPointToMove,vecPointNewPos,iPlaneType);
		//this->vecTestPoint=Pwh3D.outer_boundary;
		//this->vecTestPoint.insert(this->vecTestPoint.end(),Pwh3D.outer_boundary.begin(),Pwh3D.outer_boundary.end());
	}
	//extrude
	for (unsigned int i=0;i<Pwh3D.outer_boundary.size();i++)
	{
		if (vecPointToMove.empty())
		{
			NewOutBound.push_back(Pwh3D.outer_boundary.at(i)+HeightVec/2);
		}
		else
		{
			NewOutBound.push_back(Pwh3D.outer_boundary.at(i)+HeightVec/4);
		}
	}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
			//set<int> setInnerCSId;
			//Pwh_list_2 SubResult;
			////check all the inner holes
			//for (unsigned int j=i+1;j<InputCN.CurveInOut.size();j++)
			//{
			//	if (InputCN.CurveInOut.at(j)==i)//this hole is inside the outer of hole/circle,subtract!
			//	{
			//		Pwh_list_2 CurrentInnerPwh=InOutPOF.vecPwhList2D.at(j);
			//		for (Pwh_list_2::const_iterator  Pwh_Outer_Iter= InOutPOF.vecPwhList2D.at(i).begin();Pwh_Outer_Iter!= InOutPOF.vecPwhList2D.at(i).end(); Pwh_Outer_Iter++) 
			//		{
			//			for (Pwh_list_2::const_iterator  Pwh_Inner_Iter= CurrentInnerPwh.begin();Pwh_Inner_Iter!= CurrentInnerPwh.end(); Pwh_Inner_Iter++)
			//			{
			//				Pwh_list_2 TempResult;
			//				CGAL::difference(*Pwh_Outer_Iter,*Pwh_Inner_Iter,std::back_inserter(TempResult));
			//				if (!TempResult.empty())
			//				{
			//					SubResult.insert(SubResult.end(),TempResult.begin(),TempResult.end());
			//					setInnerCSId.insert(j);
			//				}
			//				else
			//				{
			//					DBWindowWrite("Unable to compute difference\n");
			//				}
			//			}
			//		}
			//	}
			//}
			////save the subtraction result(if it exists)
			//if (!SubResult.empty())
			//{
			//	InOutPOF.vecPwhList2D.at(i)=SubResult;
			//}
//////////////////////////////////////////////////////////////////////////////////////////////////////////

	//glLineWidth(3.0);
	//glDisable(GL_LIGHTING);
	////draw cutting stroke
	//if (!this->UserInput2DProfile.empty())
	//{
	//	for (unsigned int i=0;i<this->UserInput2DProfile.size()-1;i++)
	//	{
	//		GLdouble  winX, winY, winZ; 
	//		GLdouble posX, posY, posZ; 

	//		winX =this->UserInput2DProfile.at(i).x;
	//		winY = viewport[3] - (float)this->UserInput2DProfile.at(i).y;
	//		glReadPixels((int)winX, (int)winY, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &winZ); 
	//		gluUnProject(winX, winY, 0.0, modelview, projection, viewport, &posX, &posY, &posZ);
	//		Point_3 CurrentPoint(posX,posY,posZ);

	//		winX =this->UserInput2DProfile.at(i+1).x;
	//		winY = viewport[3] - (float)this->UserInput2DProfile.at(i+1).y;
	//		glReadPixels((int)winX, (int)winY, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &winZ); 
	//		gluUnProject(winX, winY, 0.0, modelview, projection, viewport, &posX, &posY, &posZ);
	//		Point_3 NextPoint(posX,posY,posZ);

	//		glBegin(GL_LINES);
	//		glColor3f(1,0,0);
	//		glVertex3d(CurrentPoint.x(),CurrentPoint.y(),CurrentPoint.z());
	//		glVertex3d(NextPoint.x(),NextPoint.y(),NextPoint.z());
	//		glEnd();
	//	}
	//} 
	//glEnable(GL_LIGHTING);
	//glLineWidth(1.0);

bool CMeshCreation::Fit3DProfiles()
{
	//	if (!bCurvesLeftToFit)
	//	{
	//		return false;
	//	}
	//
	//	if (this->Profile3D.size()<2)
	//	{
	//		return false;
	//	}
	//
	//	for (unsigned int i=0;i<this->Profile3D.size()-1;i++)
	//	{
	//		if (this->ProfilePlaneType.at(i)==this->ProfilePlaneType.back())
	//		{
	//			continue;
	//		}
	//		
	//		//get intersection points between curve0 and plane1
	//		vector<vector<int> > SegPoinsInd0;
	//		vector<Point_3> InterSectPoints0;
	//		int iIntersectNum=GeometryAlgorithm::GetClosedCurvePlaneIntersection(this->Profile3D.back(),
	//												this->ProfilePlane.at(i),
	//												SegPoinsInd0,InterSectPoints0);
	//		if (iIntersectNum<2)
	//		{
	//			DBWindowWrite("Curve Intersection Err0 iIntersectNum:%d\n",iIntersectNum);
	//			MessageBox(NULL,"Curve Intersection Err0!","",MB_OK);
	//			continue;
	//		}
	//
	//		//get intersection points between curve1 and plane0
	//		vector<vector<int> > SegPoinsInd1;
	//		vector<Point_3> InterSectPoints1;
	//		iIntersectNum=GeometryAlgorithm::GetClosedCurvePlaneIntersection(this->Profile3D.at(i),
	//												this->ProfilePlane.back(),
	//												SegPoinsInd1,InterSectPoints1);
	//		if (iIntersectNum<2)
	//		{
	//			DBWindowWrite("Curve Intersection Err1 iIntersectNum:%d\n",iIntersectNum);
	//			MessageBox(NULL,"Curve Intersection Err1!","",MB_OK);
	//			continue;
	//		}
	//
	//		//there're totally 4 intersection points, group them according to positions
	//		if (CGAL::has_larger_distance_to_point(InterSectPoints0.front(),
	//			InterSectPoints1.front(),InterSectPoints1.back()))
	//		{
	//			reverse(InterSectPoints1.begin(),InterSectPoints1.end());
	//			reverse(SegPoinsInd1.begin(),SegPoinsInd1.end());
	//		}
	//
	//		//generate the two new merged points
	//		Point_3 NewPoints[2];
	//		for (int j=0;j<2;j++)
	//		{
	//			NewPoints[j]=CGAL::midpoint(InterSectPoints0.at(j),InterSectPoints1.at(j));
	//		}
	//
	//		//move the points on the original curve those are nearset to new points
	//		//to the new points
	//		vector<int> vecHandleIndex0,vecHandleIndex1;
	//		vector<Point_3> vecHandleNewPos0,vecHandleNewPos1;
	//
	//		for (int j=0;j<2;j++)
	//		{
	//			vector<int> temp0=SegPoinsInd0.at(j);
	//			if (CGAL::has_larger_distance_to_point(NewPoints[j],
	//				this->Profile3D.back().at(temp0.at(0)),
	//				this->Profile3D.back().at(temp0.at(1))))
	//			{
	//				vecHandleIndex0.push_back(temp0.at(1));
	//				vecHandleNewPos0.push_back(NewPoints[j]);
	////				this->Profile3D.back().at(temp0.at(1))=NewPoints[j];
	//			}
	//			else
	//			{
	//				vecHandleIndex0.push_back(temp0.at(1));
	//				vecHandleNewPos0.push_back(NewPoints[j]);
	////				this->Profile3D.back().at(temp0.at(0))=NewPoints[j];
	//			}
	//
	//			vector<int> temp1=SegPoinsInd1.at(j);
	//			if (CGAL::has_larger_distance_to_point(NewPoints[j],
	//				this->Profile3D.at(i).at(temp1.at(0)),
	//				this->Profile3D.at(i).at(temp1.at(1))))
	//			{
	//				vecHandleIndex1.push_back(temp1.at(1));
	//				vecHandleNewPos1.push_back(NewPoints[j]);
	////				this->Profile3D.at(i).at(temp1.at(1))=NewPoints[j];
	//			}
	//			else
	//			{
	//				vecHandleIndex1.push_back(temp1.at(1));
	//				vecHandleNewPos1.push_back(NewPoints[j]);
	////				this->Profile3D.at(i).at(temp1.at(0))=NewPoints[j];
	//			}
	//		}
	//
	//		CCurveDeform::OpenCurveNaiveLaplacianDeform(this->Profile3D.back(),vecHandleIndex0,
	//												vecHandleNewPos0,6,this->ProfilePlaneType.back());
	//		CCurveDeform::OpenCurveNaiveLaplacianDeform(this->Profile3D.at(i),vecHandleIndex1,
	//												vecHandleNewPos1,6,this->ProfilePlaneType.at(i));
	//
	////		CCurveDeform::ClosedCurveNaiveLaplacianDeform(this->Profile3D.back(),vecHandleIndex0,
	////												vecHandleNewPos0,this->ProfilePlaneType.back());
	////		CCurveDeform::ClosedCurveNaiveLaplacianDeform(this->Profile3D.at(i),vecHandleIndex1,
	////												vecHandleNewPos1,this->ProfilePlaneType.at(i));
	//
	//	}
	//
	//	this->bCurvesLeftToFit=false;
	//	GetCurvePlaneIntersectPoints();
	return true;
}



	//this->AnchorVertices=AnchorBack;
	//CEdgeBasedDeform::EdgeBasedDeform(dLamda,iType,iIterNum,Mesh,vecHandlePoint,vecHandleNbVertex,ROIVertices,AnchorVertices,
	//		vecDeformCurvePoint3d,vecTestPoint);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream outEdgeLap("bbbbbb.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(outEdgeLap,Mesh);

	//flexible edge 0 aniso
	dLamda=0;
	CWedgeEdgeBasedDeform::WedgeEdgeBasedDeform(dLamda,iType,iIterNum,Mesh,vecHandlePoint,vecHandleNbVertex,ROIVertices,AnchorVertices,
		vecDeformCurvePoint3d,vecTestPoint,false);
	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	std::ofstream outWedgeEdgeLap0aniso("edge0-aniso.obj",ios_base::out | ios_base::trunc);
	print_polyhedron_wavefront(outWedgeEdgeLap0aniso,Mesh);

	CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);


	//flexible edge 0.5 aniso
	dLamda=0.5;
	CWedgeEdgeBasedDeform::WedgeEdgeBasedDeform(dLamda,iType,iIterNum,Mesh,vecHandlePoint,vecHandleNbVertex,ROIVertices,AnchorVertices,
		vecDeformCurvePoint3d,vecTestPoint,false);
	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	std::ofstream outWedgeEdgeLap05aniso("edge05-aniso.obj",ios_base::out | ios_base::trunc);
	print_polyhedron_wavefront(outWedgeEdgeLap05aniso,Mesh);

	CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);

	//flexible edge 1.0 aniso
	dLamda=1.0;
	CWedgeEdgeBasedDeform::WedgeEdgeBasedDeform(dLamda,iType,iIterNum,Mesh,vecHandlePoint,vecHandleNbVertex,ROIVertices,AnchorVertices,
		vecDeformCurvePoint3d,vecTestPoint,false);
	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	std::ofstream outWedgeEdgeLap10aniso("edge10-aniso.obj",ios_base::out | ios_base::trunc);
	print_polyhedron_wavefront(outWedgeEdgeLap10aniso,Mesh);



	//CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);

	//this->AnchorVertices=AnchorBack;

	//if (this->AnchorVertices.empty())//the whole mesh involves in the computation
	//{
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(Mesh);
	//	} 
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(Mesh,iType);
	//	}
	//}
	//else
	//{
	//	vector<Vertex_handle> temp=this->vecHandleNbVertex;
	//	temp.insert(temp.end(),this->ROIVertices.begin(),this->ROIVertices.end());
	//	temp.insert(temp.end(),this->AnchorVertices.begin(),this->AnchorVertices.end());
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
	//	}
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
	//	}
	//}

	//iIterNum=5;
	//dLamda=0.5;
	//CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out05("05flexible.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out05,Mesh);
///////////////////////////////////////////////////////////////
	//CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);

	//this->AnchorVertices=AnchorBack;

	//if (this->AnchorVertices.empty())//the whole mesh involves in the computation
	//{
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(Mesh);
	//	} 
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(Mesh,iType);
	//	}
	//}
	//else
	//{
	//	vector<Vertex_handle> temp=this->vecHandleNbVertex;
	//	temp.insert(temp.end(),this->ROIVertices.begin(),this->ROIVertices.end());
	//	temp.insert(temp.end(),this->AnchorVertices.begin(),this->AnchorVertices.end());
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
	//	}
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
	//	}
	//}

	//iIterNum=5;
	//dLamda=1;
	//CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out1("1flexible.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out1,Mesh);
/////////////////////////////////////////////////////////////////
//	CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
//	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
//
//	dLamda=0;
//	iIterNum=5;
//	this->AnchorVertices=AnchorBack;
//	CEdgeBasedDeform::EdgeBasedDeform(dLamda,iType,iIterNum,Mesh,vecHandlePoint,vecHandleNbVertex,ROIVertices,AnchorVertices,
//		vecDeformCurvePoint3d,vecTestPoint);
//
//
////	CEdgeBasedDeform::IterativeEdgeBasedDeform(iType,5,Mesh,vecHandlePoint,vecHandleNbVertex,
////		ROIVertices,AnchorVertices,vecDeformCurvePoint3d,vecTestPoint);
//	
//	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
//	std::ofstream out2("2Edge.obj",ios_base::out | ios_base::trunc);
//	print_polyhedron_wavefront(out2,Mesh);

///////////////////////////////////////////////////////////////////////////
//	vector<Vertex_handle> temp=this->vecHandleNbVertex;
//	temp.insert(temp.end(),this->ROIVertices.begin(),this->ROIVertices.end());
//	temp.insert(temp.end(),this->AnchorVertices.begin(),this->AnchorVertices.end());
//	if (iType==1)
//	{
//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
//	}
//	else
//	{
//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
//	}
//
//	iIterNum=5;
//	dLamda=0;
//	CRSRCellDeform::RSRCellDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
//		this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
//	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
//	std::ofstream outRSRCell("RSRCell.obj",ios_base::out | ios_base::trunc);
//	print_polyhedron_wavefront(outRSRCell,Mesh);
//
////////////////////////////////////////////////////////////////////////
//	CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
//	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
//
//	this->AnchorVertices=AnchorBack;
//	if (iType==1)
//	{
//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
//	}
//	else
//	{
//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
//	}
//
//	iIterNum=5;
//	dLamda=0;
//	CDeformationAlgorithm::FlexibleRSRDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
//		this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
//	//CDeformationAlgorithm::IterativeFlexibleDeform(dLamda,iType,10,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
//	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
//	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
//	std::ofstream out0RSR("0RSRflexible.obj",ios_base::out | ios_base::trunc);
//	print_polyhedron_wavefront(out0RSR,Mesh);
/////////////////////////////////////////////////////////////////
//	CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
//	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
//
//	this->AnchorVertices=AnchorBack;
//	if (iType==1)
//	{
//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
//	}
//	else
//	{
//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
//	}
//	iIterNum=5;
//	dLamda=0.5;
//	CDeformationAlgorithm::FlexibleRSRDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
//		this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
//	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
//	std::ofstream out05RSR("05RSRflexible.obj",ios_base::out | ios_base::trunc);
//	print_polyhedron_wavefront(out05RSR,Mesh);
////////////////////////////////////////////////////////////////////////
//	CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
//	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
//
//	this->AnchorVertices=AnchorBack;
//	if (iType==1)
//	{
//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
//	}
//	else
//	{
//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
//	}
//	iIterNum=5;
//	dLamda=0;
//	CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
//		this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
//	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
//	std::ofstream out0("0flexible.obj",ios_base::out | ios_base::trunc);
//	print_polyhedron_wavefront(out0,Mesh);
///////////////////////////////////////////////////////////////////////
//	CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
//	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
//
//	this->AnchorVertices=AnchorBack;
//
//	if (iType==1)
//	{
//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
//	}
//	else
//	{
//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
//	}
//
//	iIterNum=5;
//	dLamda=0.5;
//	CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
//		this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
//	//CDeformationAlgorithm::IterativeFlexibleDeform(dLamda,iType,10,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
//	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
//	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
//	std::ofstream out05("05flexible.obj",ios_base::out | ios_base::trunc);
//	print_polyhedron_wavefront(out05,Mesh);
/////////////////////////////////////////////////////////////////
//	CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
//	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
//
//	this->AnchorVertices=AnchorBack;
//
//	if (iType==1)
//	{
//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
//	}
//	else
//	{
//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
//	}
//
//	iIterNum=5;
//	dLamda=1;
//	CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
//		this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
//	//CDeformationAlgorithm::IterativeFlexibleDeform(dLamda,iType,10,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
//	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
//	OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
//	std::ofstream out1("1flexible.obj",ios_base::out | ios_base::trunc);
//	print_polyhedron_wavefront(out1,Mesh);
/////////////////////////////////////////////////////////////////

CDualMeshDeform::BuildDualMesh(Mesh,this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->DualMesh,
	this->vecDualHandle,this->vecDualROI,this->vecDualAnchor);

vector<Vertex_handle> temp=this->vecDualHandle;
temp.insert(temp.end(),this->vecDualROI.begin(),this->vecDualROI.end());
temp.insert(temp.end(),this->vecDualAnchor.begin(),this->vecDualAnchor.end());

//test
GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);


CDualMeshDeform::FlexibleDualMeshDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,
	this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d,
	this->DualMesh,vecDualHandle,vecDualROI,vecDualAnchor);
OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
DualMesh.clear();
this->vecDualHandle.clear();this->vecDualROI.clear();this->vecDualAnchor.clear();


//test matrix
vector<vector<double>> LeftHandMatrixATEST;
for (int i=0;i<LeftHandMatrixA.NRows();i++)
{
	vector<double> CurrentRow;
	for (int j=0;j<LeftHandMatrixA.NCols();j++)
	{
		if (LeftHandMatrixA[i][j]!=0)
		{
			CurrentRow.push_back(LeftHandMatrixA[i][j]);
		}
		else
		{
			CurrentRow.push_back(0);
		}
	}
	LeftHandMatrixATEST.push_back(CurrentRow);
}
//test matrix

void CDualMeshDeform::TestPrint(vector<vector<double>> Matrix0,vector<vector<double>> RHS0, 
								vector<vector<double>>& Matrix1,vector<vector<double>>& RHS1,
								int iFacetNum)
{
	//get corresponding order of Matrix0 and Matrix1
	vector<vector<int>> NonZero0,NonZero1;
	for (unsigned int i=0;i<Matrix0.size();i++)
	{
		vector<int> CurrentRow;
		for (unsigned int j=0;j<Matrix0.at(i).size();j++)
		{
			if (Matrix0.at(i).at(j)!=0)
			{
				CurrentRow.push_back(j);
			}
		}
		NonZero0.push_back(CurrentRow);
		if (i==iFacetNum-1)
		{
			break;
		}
	}

	for (unsigned int i=0;i<Matrix1.size();i++)
	{
		vector<int> CurrentRow;
		for (unsigned int j=0;j<Matrix1.at(i).size();j++)
		{
			if (Matrix1.at(i).at(j)!=0)
			{
				CurrentRow.push_back(j);
			}
		}
		NonZero1.push_back(CurrentRow);
		if (i==iFacetNum-1)
		{
			break;
		}
	}

	//re-sort
	vector<vector<double>> NewMatrix1,NewRHS1;
	NewRHS1=RHS1;
	for (unsigned int i=0;i<NonZero0.size();i++)
	{
		vector<vector<int>>::iterator IterToAdjust=find(NonZero1.begin(),NonZero1.end(),NonZero0.at(i));
		if (IterToAdjust!=NonZero1.end())
		{
			//adjust Laplacian matrix
			int iPlace=IterToAdjust-NonZero1.begin();
			NewMatrix1.push_back(Matrix1.at(iPlace));
			//adjust RHS
			for (int j=0;j<3;j++)
			{
				NewRHS1.at(j).at(i)=RHS1.at(j).at(iPlace);
			}
		} 
		else
		{
			MessageBox(NULL,"error","",MB_OK);
		}
	}

	for (unsigned int i=iFacetNum;i<Matrix1.size();i++)
	{
		NewMatrix1.push_back(Matrix1.at(i));
	}
	Matrix1=NewMatrix1;

	FILE* pfile=fopen("RHS1-before.txt","w");
	for (unsigned int i=0;i<RHS1.front().size();i++)
	{
		for (int j=0;j<3;j++)
		{
			fprintf(pfile,"%f,",RHS1.at(j).at(i));
		}
		fprintf(pfile,"\n");
	}
	fclose(pfile);
	
	RHS1=NewRHS1;

	pfile=fopen("RHS1-after.txt","w");
	for (unsigned int i=0;i<RHS1.front().size();i++)
	{
		for (int j=0;j<3;j++)
		{
			fprintf(pfile,"%f,",RHS1.at(j).at(i));
		}
		fprintf(pfile,"\n");
	}
	fclose(pfile);

	pfile=fopen("RHS0.txt","w");
	for (unsigned int i=0;i<RHS0.front().size();i++)
	{
		for (int j=0;j<3;j++)
		{
			fprintf(pfile,"%f,",RHS0.at(j).at(i));
		}
		fprintf(pfile,"\n");
	}
	fclose(pfile);

	pfile=fopen("Laplacian0.txt","w");
	for (unsigned int i=0;i<Matrix0.size();i++)
	{
		for (unsigned int j=0;j<Matrix0.at(i).size();j++)
		{
			if (Matrix0.at(i).at(j)!=0)
			{
				fprintf(pfile,"%d: %f,",j,Matrix0.at(i).at(j));
			}
		}
		fprintf(pfile,"\n");
	}
	fclose(pfile);

	pfile=fopen("Laplacian1.txt","w");
	for (unsigned int i=0;i<Matrix1.size();i++)
	{
		for (unsigned int j=0;j<Matrix1.at(i).size();j++)
		{
			if (Matrix1.at(i).at(j)!=0)
			{
				fprintf(pfile,"%d: %f,",j,Matrix1.at(i).at(j));
			}
		}
		fprintf(pfile,"\n");
	}
	fclose(pfile);

	//NonZero0.clear();NonZero1.clear();
	//for (unsigned int i=0;i<Matrix0.size();i++)
	//{
	//	vector<int> CurrentRow;
	//	for (unsigned int j=0;j<Matrix0.at(i).size();j++)
	//	{
	//		if (Matrix0.at(i).at(j)!=0)
	//		{
	//			CurrentRow.push_back(j);
	//		}
	//	}
	//	NonZero0.push_back(CurrentRow);
	//	if (i==iFacetNum-1)
	//	{
	//		break;
	//	}
	//}

	//for (unsigned int i=0;i<Matrix1.size();i++)
	//{
	//	vector<int> CurrentRow;
	//	for (unsigned int j=0;j<Matrix1.at(i).size();j++)
	//	{
	//		if (Matrix1.at(i).at(j)!=0)
	//		{
	//			CurrentRow.push_back(j);
	//		}
	//	}
	//	NonZero1.push_back(CurrentRow);
	//	if (i==iFacetNum-1)
	//	{
	//		break;
	//	}
	//}
}



if (iNbIndex0!=0&&iNbIndex1!=0)
{
	if (NeighborEdges.at(i).front()->opposite()->vertex()==vecAllVertex.at(j))
	{
		CurrentRow.push_back(-0.5*vecAllEdge.at(i)->GetEdgeWeights().front()-0.5*vecAllEdge.at(i)->GetEdgeWeights().back());
	}
	else if (NeighborEdges.at(i).at(EndVer0->vertex_degree()-2)->opposite()->vertex()==vecAllVertex.at(j))
	{
		CurrentRow.push_back(-0.5*vecAllEdge.at(i)->GetEdgeWeights().at(EndVer0->vertex_degree()-2)
			-0.5*vecAllEdge.at(i)->GetEdgeWeights().at(EndVer0->vertex_degree()-1));
	}
	else
	{
		AfxMessageBox("error1!");
		testpoints.push_back(EndVer0->point());
		testpoints.push_back(EndVer1->point());
		testpoints.push_back(vecAllVertex.at(j)->point());
		return;
		//int itest=EndVer0->vertex_degree();
		//int itest2=EndVer1->vertex_degree();
		//Vertex_handle test2=vecAllVertex.at(j);
		//for (unsigned int k=0;k<NeighborEdges.at(i).size();k++)
		//{
		//	Vertex_handle test=NeighborEdges.at(i).at(k)->opposite()->vertex();
		//	int isee=k;
		//}
	}
}
else if (iNbIndex0!=0||iNbIndex1!=0)
{
	for (unsigned int k=0;k<NeighborEdges.at(i).size();k++)
	{
		if (NeighborEdges.at(i).at(k)->opposite()->vertex()==vecAllVertex.at(j))
		{
			CurrentRow.push_back(-0.5*(vecAllEdge.at(i)->GetEdgeWeights().at(k)));
			break;
		}
		if (k==NeighborEdges.at(i).size()-1)
		{
			AfxMessageBox("error2!");
		}
	}
}



	char TRANS='N';
	int temp=LeftMatrixA.size();
	integer iMatARow=temp;
	temp=LeftMatrixA.front().size();
	integer iMatACol=temp;
	temp=RightMatrixB.size();
	integer iMatBCol=temp;

	bool bOverDetermine=false;
	if (iMatARow>iMatACol)//overdetermined 
	{
		bOverDetermine=true;
	}
	int iFunctionNum=(int)LeftMatrixA.size();
	int iUnknownNumInEachGroup=(int)LeftMatrixA.front().size();
	int iGroupNum=(int)RightMatrixB.size();



	//if (iMatARow*iMatACol>1999*1999)
	//{
	//	AfxMessageBox("not enough memo for matrix");
	//	return false;
	//}
	double* A=new double[LeftMatrixA.size()*LeftMatrixA.front().size()];
	memset(A,0x00,LeftMatrixA.size()*LeftMatrixA.front().size()*sizeof(double));
	int iIndex=0;
	for (unsigned int i=0;i<LeftMatrixA.front().size();i++)
	{
		for (unsigned int j=0;j<LeftMatrixA.size();j++)
		{
			A[iIndex]=LeftMatrixA.at(j).at(i);
			iIndex++;
		}
	}

	integer LDA=iMatARow;

	double* B=new double[RightMatrixB.size()*RightMatrixB.front().size()];
	memset(B,0x00,RightMatrixB.size()*RightMatrixB.front().size()*sizeof(double));
	iIndex=0;
	for (unsigned int i=0;i<RightMatrixB.size();i++)
	{
		for (unsigned int j=0;j<RightMatrixB.front().size();j++)
		{
			B[iIndex]=RightMatrixB.at(i).at(j);
			iIndex++;
		}
		if (!bOverDetermine)//since B is of dimension (LDB,NRHS)!!!
		{
			for (int j=0;j<iUnknownNumInEachGroup-iFunctionNum;j++)
			{
				iIndex++;
			}
		}
	}

	integer LDB=max(iMatARow,iMatACol);

	long iWorkSize=min(LeftMatrixA.size(),LeftMatrixA.front().size())+max(min(LeftMatrixA.size(),LeftMatrixA.front().size()),RightMatrixB.size());
	double* WORK=new double[iWorkSize];
	memset(WORK,0x00,iWorkSize*sizeof(double));
//	integer LWORK=min(iMatARow,iMatACol)+max(iMatARow*iMatACol,iMatBCol)*256;
	integer LWORK=iWorkSize;
	integer INFO=0;

	dgels_(&TRANS,&iMatARow,&iMatACol,&iMatBCol,A,&LDA,B,&LDB,WORK,&LWORK,&INFO);

	if (INFO==0)
	{
		iIndex=0;
		for (int i=0;i<iGroupNum;i++)
		{
			vector<double> CurrentResult;
			for (int j=0;j<iUnknownNumInEachGroup;j++)
			{
				CurrentResult.push_back(B[iIndex]);
				iIndex++;
			}
			if (bOverDetermine)
			{
				for (int j=0;j<iFunctionNum-iUnknownNumInEachGroup;j++)
				{
					//these B[iIndex] stores the residual sum of squares for the
					//solution for each group,so skip it
					iIndex++;
				}
			}
			Result.push_back(CurrentResult);
		}
		delete [] A;
		delete [] B;
		delete [] WORK;
		return true;
	}

	delete [] A;
	delete [] B;
	delete [] WORK;
	return false;
	
	
	
	
	
		double value[5];
	int colptr[4];
	int rowind[5];
	double RHS[3];

	// create CCS matrix structure using vector class
	value[0]=2.0;
	value[1]=-1.0;
	value[2]=2.0;
	value[3]=-1.0;
	value[4]=2.0;

	colptr[0]=0;
	colptr[1]=2;
	colptr[2]=4;
	colptr[3]=5;

	rowind[0]=0;
	rowind[1]=1;
	rowind[2]=1;
	rowind[3]=2;
	rowind[4]=2;

	// create right-hand size vector object
	RHS[0] = 10.0;
	RHS[1] = 2.0;
	RHS[2] = 3.0;

	// resize vectors.
	int dim = 3;

	// create TAUCS matrix from vector objects an, jn and ia
	taucs_ccs_matrix  A; // a matrix to solve Ax=b in CCS format
	A.n = dim;
	A.m = dim;
	A.flags = (TAUCS_DOUBLE | TAUCS_SYMMETRIC | TAUCS_LOWER);
	A.colptr = colptr;
	A.rowind = rowind;
	A.values.d = value;

	//RHS related
	taucs_double bod[3]; 

	// allocate TAUCS solution vector
	double result[3];
	double xod[3];

	// solve the linear system
	//Using TAUCS low-level routines
	int*         perm;
	int*         invperm;
	taucs_ccs_matrix*  Aod;

	void* F = NULL;
	char* options[] = {"taucs.factor.LLT=true", NULL};
	void* opt_arg[] = { NULL };

	// 1) Reordering
	taucs_ccs_order(&A, &perm, &invperm, "metis");
	Aod = taucs_ccs_permute_symmetrically(&A, perm, invperm);
	taucs_vec_permute(dim, TAUCS_DOUBLE, RHS, bod, perm);

	// 2) Factoring
	F = taucs_ccs_factor_llt_mf(Aod);	

	// 3) Back substitution and reodering the solution back
	taucs_supernodal_solve_llt(F, xod, bod);	
	taucs_vec_ipermute(dim, TAUCS_DOUBLE, xod, result, perm);



//	int i = taucs_linsolve(&A, &F, 1, x, RHS, options, opt_arg);

	//if (i != TAUCS_SUCCESS)
	//{
	//	cout << "Solution error." << endl;
	//	if (i==TAUCS_ERROR)
	//		cout << "Generic error." << endl;

	//	if (i==TAUCS_ERROR_NOMEM)
	//		cout << "NOMEM error." << endl;

	//	if (i==TAUCS_ERROR_BADARGS)
	//		cout << "BADARGS error." << endl;

	//	if (i==TAUCS_ERROR_MAXDEPTH)
	//		cout << "MAXDEPTH error." << endl;

	//	if (i==TAUCS_ERROR_INDEFINITE)
	//		cout << "NOT POSITIVE DEFINITE error." << endl;
	//}
	//else
	//{
	//	cout << "Solution success." << endl;

	//	for (unsigned j = 0; j < 4; j++)
	//		cout << x[j] << endl;
	//}

	// deallocate the factorization
	taucs_supernodal_factor_free(F);
	taucs_ccs_free(Aod);			

//	taucs_linsolve(NULL, &F, 0, NULL, NULL, NULL, NULL);









	float value[5];
	int colptr[4];
	int rowind[5];
	float RHS[3];

	// create CCS matrix structure using vector class
	value[0]=2.0;
	value[1]=-1.0;
	value[2]=2.0;
	value[3]=-1.0;
	value[4]=2.0;

	colptr[0]=0;
	colptr[1]=2;
	colptr[2]=4;
	colptr[3]=5;

	rowind[0]=0;
	rowind[1]=1;
	rowind[2]=1;
	rowind[3]=2;
	rowind[4]=2;

	// create right-hand size vector object
	RHS[0] = 10.0;
	RHS[1] = 2.0;
	RHS[2] = 3.0;

	// resize vectors.
	int dim = 3;

	// create TAUCS matrix from vector objects an, jn and ia
	taucs_ccs_matrix* A = taucs_dccs_create(dim, dim, 5);
	
//	taucs_ccs_matrix  A; // a matrix to solve Ax=b in CCS format
//	A->n = dim;
//	A->m = dim;
	A->flags = (TAUCS_SINGLE | TAUCS_SYMMETRIC | TAUCS_LOWER);
	A->colptr = colptr;
	A->rowind = rowind;
	A->values.s = value;

	// solve the linear system
	//Using TAUCS low-level routines
	int*         perm;
	int*         invperm;
	taucs_ccs_matrix*  Aod;

	void* F = NULL;

	// 1) Reordering
	taucs_ccs_order(A, &perm, &invperm, "metis");
	Aod = taucs_ccs_permute_symmetrically(A, perm, invperm);

	// 2) Factoring
	F = taucs_ccs_factor_llt_mf(Aod);	
	taucs_ccs_free(Aod);			
//	taucs_ccs_free(A);			


	// 3) Back substitution and reodering the solution back
	//RHS related
	float bod[3]; 
	// allocate TAUCS solution vector
	float result[3];
	float xod[3];
	taucs_vec_permute(dim, TAUCS_SINGLE, RHS, bod, perm);
	int i=taucs_supernodal_solve_llt(F, xod, bod);	
	taucs_vec_ipermute(dim, TAUCS_SINGLE, xod, result, perm);

	RHS[0]=2;RHS[1]=5;RHS[2]=8;
	taucs_vec_permute(dim, TAUCS_SINGLE, RHS, bod, perm);
	i=taucs_supernodal_solve_llt(F, xod, bod);	
	taucs_vec_ipermute(dim, TAUCS_SINGLE, xod, result, perm);

	// deallocate the factorization
	taucs_supernodal_factor_free(F);
	
	
	
	
	
	//////////////////////////

//////////////////////////
	//iIterNum=5;
	//dLamda=0;
	//CDeformationAlgorithm::BuildDualMesh(Mesh,this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->DualMesh,
	//	this->vecDualHandle,this->vecDualROI,this->vecDualAnchor);

	//vector<Vertex_handle> temp=this->vecDualHandle;
	//temp.insert(temp.end(),this->vecDualROI.begin(),this->vecDualROI.end());
	//temp.insert(temp.end(),this->vecDualAnchor.begin(),this->vecDualAnchor.end());

	////test
	//int iType=1;
	//if (iType==1)
	//{
	//	GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
	//}
	//else
	//{
	//	GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
	//}


	//CDeformationAlgorithm::FlexibleDualMeshDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,
	//	this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d,
	//	this->DualMesh,vecDualHandle,vecDualROI,vecDualAnchor);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out0("000.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out0,Mesh);
	//DualMesh.clear();
	//this->vecDualHandle.clear();this->vecDualROI.clear();this->vecDualAnchor.clear();
////////////////////////

	//iIterNum=5;
	//dLamda=0.5;
	//CDeformationAlgorithm::BuildDualMesh(Mesh,this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->DualMesh,
	//	this->vecDualHandle,this->vecDualROI,this->vecDualAnchor);

	//temp=this->vecDualHandle;
	//temp.insert(temp.end(),this->vecDualROI.begin(),this->vecDualROI.end());
	//temp.insert(temp.end(),this->vecDualAnchor.begin(),this->vecDualAnchor.end());

	////test
	//iType=1;
	//if (iType==1)
	//{
	//	GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
	//}
	//else
	//{
	//	GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
	//}


	//CDeformationAlgorithm::FlexibleDualMeshDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,
	//	this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d,
	//	this->DualMesh,vecDualHandle,vecDualROI,vecDualAnchor);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out1("111.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out1,Mesh);
	//DualMesh.clear();
	//this->vecDualHandle.clear();this->vecDualROI.clear();this->vecDualAnchor.clear();


/////////////////////////////////
	//CDeformationAlgorithm::BuildDualMesh(Mesh,this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->DualMesh,
	//	this->vecDualHandle,this->vecDualROI,this->vecDualAnchor);

	//CDeformationAlgorithm::DualMeshRigidDeformTest(1,1,Mesh,vecHandlePoint,vecHandleNbVertex,ROIVertices,AnchorVertices,vecDeformCurvePoint3d,
	//	DualMesh,vecDualHandle,vecDualROI,vecDualAnchor);

	//return;
/////////////////////////////////
	//vector<Point_3> OldPos;
	//CDeformationAlgorithm::BackUpMeshGeometry(Mesh,OldPos);

	////back up anchor
	//vector<Vertex_handle> AnchorBack=this->AnchorVertices;

	//int iType=1;//1 for uniform,2 for tan weighted,3 for cot weighted
	//if (this->AnchorVertices.empty())//the whole mesh involves in the computation
	//{
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(Mesh);
	//	} 
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(Mesh,iType);
	//	}
	//}
	//else
	//{
	//	vector<Vertex_handle> temp=this->vecHandleNbVertex;
	//	temp.insert(temp.end(),this->ROIVertices.begin(),this->ROIVertices.end());
	//	temp.insert(temp.end(),this->AnchorVertices.begin(),this->AnchorVertices.end());
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
	//	}
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
	//	}
	//}
	//
	//iIterNum=5;
	//dLamda=0.1;
	//CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	////std::ofstream out0("0flexible.obj",ios_base::out | ios_base::trunc);
	////print_polyhedron_wavefront(out0,Mesh);
	//return;
/////////////////////////////////
	//CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);

	//this->AnchorVertices=AnchorBack;
	//if (this->AnchorVertices.empty())//the whole mesh involves in the computation
	//{
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(Mesh);
	//	} 
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(Mesh,iType);
	//	}
	//}
	//else
	//{
	//	vector<Vertex_handle> temp=this->vecHandleNbVertex;
	//	temp.insert(temp.end(),this->ROIVertices.begin(),this->ROIVertices.end());
	//	temp.insert(temp.end(),this->AnchorVertices.begin(),this->AnchorVertices.end());
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
	//	}
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
	//	}
	//}

	//iIterNum=5;
	//dLamda=1.0;
	//CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out10("10flexible.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out10,Mesh);

/////////////////////////////////
	//CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);

	//this->AnchorVertices=AnchorBack;
	//if (this->AnchorVertices.empty())//the whole mesh involves in the computation
	//{
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(Mesh);
	//	} 
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(Mesh,iType);
	//	}
	//}
	//else
	//{
	//	vector<Vertex_handle> temp=this->vecHandleNbVertex;
	//	temp.insert(temp.end(),this->ROIVertices.begin(),this->ROIVertices.end());
	//	temp.insert(temp.end(),this->AnchorVertices.begin(),this->AnchorVertices.end());
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
	//	}
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
	//	}
	//}

	//iIterNum=5;
	//dLamda=0.5;
	//CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out5("5flexible.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out5,Mesh);

/////////////////////////////////
	//CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);

	//this->AnchorVertices=AnchorBack;
	//if (this->AnchorVertices.empty())//the whole mesh involves in the computation
	//{
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(Mesh);
	//	} 
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(Mesh,iType);
	//	}
	//}
	//else
	//{
	//	vector<Vertex_handle> temp=this->vecHandleNbVertex;
	//	temp.insert(temp.end(),this->ROIVertices.begin(),this->ROIVertices.end());
	//	temp.insert(temp.end(),this->AnchorVertices.begin(),this->AnchorVertices.end());
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
	//	}
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
	//	}
	//}

	//iIterNum=5;
	//dLamda=1.0;
	//CDeformationAlgorithm::BuildDualMesh(Mesh,this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->DualMesh,
	//	this->vecDualHandle,this->vecDualROI,this->vecDualAnchor);

	//vector<Vertex_handle> temp=this->vecDualHandle;
	//temp.insert(temp.end(),this->vecDualROI.begin(),this->vecDualROI.end());
	//temp.insert(temp.end(),this->vecDualAnchor.begin(),this->vecDualAnchor.end());

	////test
	//if (iType==1)
	//{
	//	GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
	//}
	//else
	//{
	//	GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
	//}


	//CDeformationAlgorithm::FlexibleDualMeshDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,
	//	this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d,
	//	this->DualMesh,vecDualHandle,vecDualROI,vecDualAnchor);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out2("dual1.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out2,Mesh);
//////////////////



//	CDeformationAlgorithm::DualMeshRigidDeform(iType,iIterNum,Mesh,this->vecHandlePoint,
//		this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d,
//		this->DualMesh,vecDualHandle,vecDualROI,vecDualAnchor);

	//CDeformationAlgorithm::FlexibleDualMeshDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,
	//	this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d,
	//	this->DualMesh,vecDualHandle,vecDualROI,vecDualAnchor);


	//CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out0("0flexible.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out0,Mesh);

	//CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//dLamda=0.2;
	//CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out2("2flexible.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out2,Mesh);

	//CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//dLamda=0.5;
	//CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out5("5flexible.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out5,Mesh);

	//CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//dLamda=0.8;
	//CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out8("8flexible.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out8,Mesh);

	//CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//dLamda=1.0;
	//CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out10("10flexible.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out10,Mesh);
	
	
		//int iType=3;//1 for uniform,2 for tan weighted,3 for cot weighted
	//if (this->AnchorVertices.empty())//the whole mesh involves in the computation
	//{
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(Mesh);
	//	} 
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(Mesh,iType);
	//	}
	//}
	//else
	//{
	//	vector<Vertex_handle> temp=this->vecHandleNbVertex;
	//	temp.insert(temp.end(),this->ROIVertices.begin(),this->ROIVertices.end());
	//	temp.insert(temp.end(),this->AnchorVertices.begin(),this->AnchorVertices.end());
	//	if (iType==1)
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
	//	}
	//	else
	//	{
	//		GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
	//	}
	//}
	//CDeformationAlgorithm::IterativeLaplacianDeform(iType,10,Mesh,vecHandlePoint,vecHandleNbVertex,ROIVertices,AnchorVertices,vecDeformCurvePoint3d);

	//CDualMeshDeform::BuildDualMesh(Mesh,this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->DualMesh,
	//	this->vecDualHandle,this->vecDualROI,this->vecDualAnchor);

	//vector<Vertex_handle> temp=this->vecDualHandle;
	//temp.insert(temp.end(),this->vecDualROI.begin(),this->vecDualROI.end());
	//temp.insert(temp.end(),this->vecDualAnchor.begin(),this->vecDualAnchor.end());

	////test
	//int iType=3;
	//if (iType==1)
	//{
	//	GeometryAlgorithm::ComputeCGALDualMeshUniformLaplacian(temp);
	//}
	//else
	//{
	//	GeometryAlgorithm::ComputeCGALDualMeshWeightedLaplacian(temp,iType);
	//}

	//CDualMeshDeform::FlexibleDualMeshDeform(1,iType,3,Mesh,this->vecHandlePoint,
	//	this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d,
	//	this->DualMesh,vecDualHandle,vecDualROI,vecDualAnchor);

	//CDualMeshDeform::IterativeDualLaplacianDeform(iType,5,Mesh,this->vecHandlePoint,
	//	this->vecHandleNbVertex,this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d,
	//	this->DualMesh,vecDualHandle,vecDualROI,vecDualAnchor);


//////////////////////////////////
	//vector<Point_3> OldPos;
	//CDeformationAlgorithm::BackUpMeshGeometry(Mesh,OldPos);

	//CDeformationAlgorithm::NaiveLaplacianDeform(iType,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out1("1naive.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out1,Mesh);

	//CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//int iIterNum=1;
	//CDeformationAlgorithm::RigidDeform(iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out2("2rigid.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out2,Mesh);

	//CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//CDeformationAlgorithm::RotatedLaplacianDeform(iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
	//	this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	//std::ofstream out3("3laplacian.obj",ios_base::out | ios_base::trunc);
	//print_polyhedron_wavefront(out3,Mesh);

	//CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
	//OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
	
	
	
	
	
	
	
	
	
	void CDeformationAlgorithm::ComputeScaleTranslationFactor(int iType,KW_Mesh& Mesh, 
											   vector<Vertex_handle>& vecHandleNb,
											   vector<Vertex_handle>& ROIVertices,
											   vector<Vertex_handle>& vecAnchorVertices)
{
	vector<Vertex_handle> vecAllVertices;
	vecAllVertices.insert(vecAllVertices.end(),vecHandleNb.begin(),vecHandleNb.end());
	vecAllVertices.insert(vecAllVertices.end(),ROIVertices.begin(),ROIVertices.end());
	//	vecAllVertices.insert(vecAllVertices.end(),vecAnchorVertices.begin(),vecAnchorVertices.end());

	for (unsigned int i=0;i<vecAllVertices.size();i++)
	{
		vector<double> RotationMatrix=vecAllVertices.at(i)->GetRigidDeformRotationMatrix();
		int iOldEdgeIndex=0;
		double dOldSum[3],dNewSum[3],dOldSquareSum[3],dOldByNewSum[3];
		for (int j=0;j<3;j++)
		{
			dOldSum[j]=dNewSum[j]=dOldSquareSum[j]=dOldByNewSum[j]=0;
		}
		Halfedge_around_vertex_circulator Havc=vecAllVertices.at(i)->vertex_begin();
		do 
		{
			//compute new edge
			Vector_3 NewEdge=vecAllVertices.at(i)->point()-Havc->opposite()->vertex()->point();
			//get corresponding old edge
			Vector_3 OldEdge=vecAllVertices.at(i)->GetOldEdgeVectors().at(iOldEdgeIndex);
			//get RotatedOldEdge=RotationMatrix*OldEdge
			double dRotatedOldEdge[3];
			dRotatedOldEdge[0]=RotationMatrix.at(0)*OldEdge.x()+
				RotationMatrix.at(1)*OldEdge.y()+
				RotationMatrix.at(2)*OldEdge.z();
			dRotatedOldEdge[1]=RotationMatrix.at(3)*OldEdge.x()+
				RotationMatrix.at(4)*OldEdge.y()+
				RotationMatrix.at(5)*OldEdge.z();
			dRotatedOldEdge[2]=RotationMatrix.at(6)*OldEdge.x()+
				RotationMatrix.at(7)*OldEdge.y()+
				RotationMatrix.at(8)*OldEdge.z();
			//get weight for the edge
			double dCurrentWeight;
			if (iType==1)
			{
				dCurrentWeight=1;
			}
			else
			{
				dCurrentWeight=vecAllVertices.at(i)->GetEdgeWeights().at(iOldEdgeIndex);
			}
			//get dNewSum
			dNewSum[0]=dNewSum[0]+dCurrentWeight*NewEdge.x();
			dNewSum[1]=dNewSum[1]+dCurrentWeight*NewEdge.y();
			dNewSum[2]=dNewSum[2]+dCurrentWeight*NewEdge.z();
			//get dOldSum
			dOldSum[0]=dOldSum[0]+dCurrentWeight*dRotatedOldEdge[0];
			dOldSum[1]=dOldSum[1]+dCurrentWeight*dRotatedOldEdge[1];
			dOldSum[2]=dOldSum[2]+dCurrentWeight*dRotatedOldEdge[2];
			//get dOldSquareSum
			dOldSquareSum[0]=dOldSquareSum[0]+dCurrentWeight*dRotatedOldEdge[0]*dRotatedOldEdge[0];
			dOldSquareSum[1]=dOldSquareSum[1]+dCurrentWeight*dRotatedOldEdge[1]*dRotatedOldEdge[1];
			dOldSquareSum[2]=dOldSquareSum[2]+dCurrentWeight*dRotatedOldEdge[2]*dRotatedOldEdge[2];
			//get dOldByNewSum
			dOldByNewSum[0]=dOldByNewSum[0]+dCurrentWeight*dRotatedOldEdge[0]*NewEdge.x();
			dOldByNewSum[1]=dOldByNewSum[1]+dCurrentWeight*dRotatedOldEdge[1]*NewEdge.y();
			dOldByNewSum[2]=dOldByNewSum[2]+dCurrentWeight*dRotatedOldEdge[2]*NewEdge.z();

			Havc++;
			iOldEdgeIndex++;
			//construct convariance matrix S
		} while(Havc!=vecAllVertices.at(i)->vertex_begin());
		double dTranslation[3],dScale[3];
		for (int j=0;j<3;j++)
		{
			vector<vector<double>> LeftMat,RightMat,Result;
			vector<double> LeftRow;
			LeftRow.push_back(dOldSquareSum[j]);
			LeftRow.push_back(dOldSum[j]);
			LeftMat.push_back(LeftRow);
			LeftRow.clear();
			LeftRow.push_back(dOldSum[j]);
			LeftRow.push_back(vecAllVertices.at(i)->vertex_degree());
			LeftMat.push_back(LeftRow);

			vector<double> RightCol;
			RightCol.push_back(dOldByNewSum[j]);
			RightCol.push_back(dNewSum[j]);
			RightMat.push_back(RightCol);

			CMath::ComputeLSESmallSize(LeftMat,RightMat,Result);
			dScale[j]=Result.front().at(0);
			dTranslation[j]=Result.front().at(1);
		}
		vecAllVertices.at(i)->SetTranslationFactor(Vector_3(dTranslation[0],dTranslation[1],dTranslation[2]));
		vecAllVertices.at(i)->SetScaleFactor(Vector_3(dScale[0],dScale[1],dScale[2]));
	}
}



void CEdgeBasedDeform::ComputeScaleTranslationFactor(int iType,vector<Halfedge_handle>& ROIEdges,vector<vector<Halfedge_handle>> NeighborEdges)
{
	for (unsigned int i=0;i<ROIEdges.size();i++)
	{
		vector<double> RotationMatrix=ROIEdges.at(i)->GetRigidDeformRotationMatrix();
		double dOldSum[3],dNewSum[3],dOldSquareSum[3],dOldByNewSum[3];
		for (int j=0;j<3;j++)
		{
			dOldSum[j]=dNewSum[j]=dOldSquareSum[j]=dOldByNewSum[j]=0;
		}

		Point_3 CurrentPoint=CGAL::midpoint(ROIEdges.at(i)->vertex()->point(),
			ROIEdges.at(i)->opposite()->vertex()->point());

		for (unsigned int j=0;j<NeighborEdges.at(i).size();j++)
		{
			//compute new edge
			Point_3 NbPoint=CGAL::midpoint(NeighborEdges.at(i).at(j)->vertex()->point(),
				NeighborEdges.at(i).at(j)->opposite()->vertex()->point());
			Vector_3 NewEdge=CurrentPoint-NbPoint;
			//get corresponding old edge
			Vector_3 OldEdge=ROIEdges.at(i)->GetOldEdgeVectors().at(j);
			//get RotatedOldEdge=RotationMatrix*OldEdge
			double dRotatedOldEdge[3];
			dRotatedOldEdge[0]=RotationMatrix.at(0)*OldEdge.x()+
				RotationMatrix.at(1)*OldEdge.y()+
				RotationMatrix.at(2)*OldEdge.z();
			dRotatedOldEdge[1]=RotationMatrix.at(3)*OldEdge.x()+
				RotationMatrix.at(4)*OldEdge.y()+
				RotationMatrix.at(5)*OldEdge.z();
			dRotatedOldEdge[2]=RotationMatrix.at(6)*OldEdge.x()+
				RotationMatrix.at(7)*OldEdge.y()+
				RotationMatrix.at(8)*OldEdge.z();
			//get weight for the edge
			double dCurrentWeight;
			if (iType==1)
			{
				dCurrentWeight=1;
			}
			else
			{
				dCurrentWeight=ROIEdges.at(i)->GetEdgeWeights().at(j);
			}
			//get dNewSum
			dNewSum[0]=dNewSum[0]+dCurrentWeight*NewEdge.x();
			dNewSum[1]=dNewSum[1]+dCurrentWeight*NewEdge.y();
			dNewSum[2]=dNewSum[2]+dCurrentWeight*NewEdge.z();
			//get dOldSum
			dOldSum[0]=dOldSum[0]+dCurrentWeight*dRotatedOldEdge[0];
			dOldSum[1]=dOldSum[1]+dCurrentWeight*dRotatedOldEdge[1];
			dOldSum[2]=dOldSum[2]+dCurrentWeight*dRotatedOldEdge[2];
			//get dOldSquareSum
			dOldSquareSum[0]=dOldSquareSum[0]+dCurrentWeight*dRotatedOldEdge[0]*dRotatedOldEdge[0];
			dOldSquareSum[1]=dOldSquareSum[1]+dCurrentWeight*dRotatedOldEdge[1]*dRotatedOldEdge[1];
			dOldSquareSum[2]=dOldSquareSum[2]+dCurrentWeight*dRotatedOldEdge[2]*dRotatedOldEdge[2];
			//get dOldByNewSum
			dOldByNewSum[0]=dOldByNewSum[0]+dCurrentWeight*dRotatedOldEdge[0]*NewEdge.x();
			dOldByNewSum[1]=dOldByNewSum[1]+dCurrentWeight*dRotatedOldEdge[1]*NewEdge.y();
			dOldByNewSum[2]=dOldByNewSum[2]+dCurrentWeight*dRotatedOldEdge[2]*NewEdge.z();
		}
		double dTranslation[3],dScale[3];
		for (int j=0;j<3;j++)
		{
			vector<vector<double>> LeftMat,RightMat,Result;
			vector<double> LeftRow;
			LeftRow.push_back(dOldSquareSum[j]);
			LeftRow.push_back(dOldSum[j]);
			LeftMat.push_back(LeftRow);
			LeftRow.clear();
			LeftRow.push_back(dOldSum[j]);
			LeftRow.push_back(NeighborEdges.at(i).size());
			LeftMat.push_back(LeftRow);

			vector<double> RightCol;
			RightCol.push_back(dOldByNewSum[j]);
			RightCol.push_back(dNewSum[j]);
			RightMat.push_back(RightCol);

			CMath::ComputeLSESmallSize(LeftMat,RightMat,Result);
			dScale[j]=Result.front().at(0);
			dTranslation[j]=Result.front().at(1);
		}
		ROIEdges.at(i)->SetTranslationFactor(Vector_3(dTranslation[0],dTranslation[1],dTranslation[2]));
		ROIEdges.at(i)->SetScaleFactor(Vector_3(dScale[0],dScale[1],dScale[2]));
	}
}









	for (int i=0;i<6;i++)
	{
		iIterNum=5;
		CDeformationAlgorithm::RestoreMeshGeometry(Mesh,OldPos);
		OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
		if (this->AnchorVertices.empty())//the whole mesh involves in the computation
		{
			if (iType==1)
			{
				GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(Mesh);
			} 
			else
			{
				GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(Mesh,iType);
			}
		}
		else
		{
			vector<Vertex_handle> temp=this->vecHandleNbVertex;
			temp.insert(temp.end(),this->ROIVertices.begin(),this->ROIVertices.end());
			temp.insert(temp.end(),this->AnchorVertices.begin(),this->AnchorVertices.end());
			if (iType==1)
			{
				GeometryAlgorithm::ComputeCGALMeshUniformLaplacian(temp);
			}
			else
			{
				GeometryAlgorithm::ComputeCGALMeshWeightedLaplacian(temp,iType);
			}
		}
		CString FileName;
		switch(i)
		{
		case 0:
			FileName="0flexible.obj";
			dLamda=0.0;
			break;
		case 1:
			FileName="2flexible.obj";
			dLamda=0.2;
			break;
		case 2:
			FileName="5flexible.obj";
			dLamda=0.5;
		    break;
		case 3:
			FileName="8flexible.obj";
			dLamda=0.8;
		    break;
		case 4:
			FileName="10flexible.obj";
			dLamda=1.0;
			break;
		default:
		    break;
		}
		CDeformationAlgorithm::FlexibleDeform(dLamda,iType,iIterNum,Mesh,this->vecHandlePoint,this->vecHandleNbVertex,
			this->ROIVertices,this->AnchorVertices,this->vecDeformCurvePoint3d);
		OBJHandle::UnitizeCGALPolyhedron(Mesh,false,false);
		std::ofstream out0(FileName,ios_base::out | ios_base::trunc);
		print_polyhedron_wavefront(out0,Mesh);
	}